<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Secret Santa â€” Sessions (GitHub Pages)</title>
<style>
  :root{--bg:#0b1020;--card:#111735;--muted:#7f8db3;--accent:#7dd3fc;--ok:#22c55e;--warn:#f59e0b;--err:#ef4444;--text:#eef2ff}
  *{box-sizing:border-box}
  body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(160deg,#0b1020,#0e1430 40%,#0c1230 100%); color:var(--text)}
  .wrap{max-width:980px;margin:40px auto;padding:24px}
  h1{font-size:28px;margin:0 0 8px}
  h2{margin:0 0 8px}
  .lead{margin:0 0 20px;color:var(--muted)}
  .card{background:rgba(255,255,255,.04);backdrop-filter: blur(6px); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:20px; box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .grid{display:grid;gap:16px}
  .g2{grid-template-columns:1fr 1fr}
  .g3{grid-template-columns:repeat(3,minmax(0,1fr))}
  @media (max-width:900px){.g2,.g3{grid-template-columns:1fr}}
  label{font-weight:600;display:block;margin-bottom:8px}
  textarea,input,select,button{width:100%; padding:12px 14px; border-radius:12px; border:1px solid rgba(255,255,255,.15); background:#0e1736; color:var(--text)}
  textarea{min-height:160px; resize:vertical}
  button{cursor:pointer; font-weight:700; letter-spacing:.02em}
  button.primary{background:linear-gradient(135deg,#2563eb,#06b6d4); border:none}
  button.secondary{background:rgba(255,255,255,.06)}
  button.success{background:linear-gradient(135deg,#16a34a,#22c55e); border:none}
  .row{display:flex; gap:12px; align-items:center}
  .row>*{flex:1}
  .muted{color:var(--muted)}
  .chip{display:inline-block;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);margin:4px 6px 0 0;font-size:12px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
  .hide{display:none}
  .divider{height:1px;background:rgba(255,255,255,.12);margin:16px 0}
  .pill{display:inline-flex;align-items:center;gap:8px;background:rgba(125,211,252,.12);border:1px solid rgba(125,211,252,.35);color:#e0f2fe;padding:8px 10px;border-radius:999px}
  .center{text-align:center}
  .overlay{position:fixed;inset:0;background:rgba(0,0,15,.7);backdrop-filter: blur(4px);display:none;align-items:center;justify-content:center;z-index:50}
  .reveal{background:var(--card); border:1px solid rgba(255,255,255,.14); border-radius:20px; padding:24px 22px; max-width:720px; margin:0 18px; box-shadow:0 20px 60px rgba(0,0,0,.45); text-align:center}
  .big{font-size:40px; font-weight:800; letter-spacing:.02em; margin:10px 0 4px}
  .gridNames{display:grid; gap:12px; grid-template-columns:repeat(auto-fit,minmax(220px,1fr));}
  .nameBtn{display:flex;align-items:center;justify-content:center; padding:14px 16px; border-radius:12px; border:1px solid rgba(255,255,255,.15); background:#0e1736; color:var(--text); font-weight:700}
  .nameBtn[disabled]{opacity:.55; cursor:not-allowed}
  .subtle{opacity:.8}
  .copy{font-size:12px}
</style>
<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore-compat.js"></script>
</head>
<body>
<div class="wrap">
  <h1>ðŸŽ„ Secret Santa â€” Sessions (no keys)</h1>
  <p class="lead">Create a session, then share the <b>single session link</b>. On that page, everyone sees <b>one button per person</b>. When a person clicks their own button, they privately see their partner and that button locks for all.</p>

  <!-- Admin / Creator View -->
  <div id="view-admin" class="card grid g2 hide">
    <div>
      <h2>1) Create session</h2>
      <label>Names (one per line)</label>
      <textarea id="names" placeholder="Alice\nBob\nCharlie\nâ€¦"></textarea>
      <div class="row" style="margin-top:10px">
        <label class="row" style="align-items:center;gap:8px;flex:0 0 auto">
          <input type="checkbox" id="noTwo" checked style="width:auto"> No mutual pairs (no Aâ†”B)
        </label>
        <button class="primary" id="btnCreate">Create session</button>
      </div>
      <div class="divider"></div>
      <p class="muted">Static app uses Firebase Firestore (Anonymous Auth). Make sure your GitHub Pages domain is in Firebase <b>Auth â†’ Authorized domains</b>.</p>
      <div class="banner" id="authInfo">Auth: <em>initializingâ€¦</em></div>
    </div>
    <div>
      <h2>2) Share this link</h2>
      <div id="share" class="muted">Create a session to get a link.</div>
      <div class="divider"></div>
      <div id="adminStatus"></div>
    </div>
  </div>

  <!-- Shared Session View -->
  <div id="view-session" class="card hide">
    <h2>Session</h2>
    <div id="sessInfo" class="muted">Loading sessionâ€¦</div>
    <div class="divider"></div>
    <div id="nameGrid" class="gridNames"></div>
    <div class="divider"></div>
    <div id="sessionStatus"></div>
  </div>
</div>

<div class="overlay" id="ov">
  <div class="reveal">
    <div class="subtle">Your person is</div>
    <div class="big" id="target">?</div>
    <div class="row" style="justify-content:center;margin-top:10px">
      <button class="secondary" id="closeOv">Close</button>
    </div>
  </div>
</div>

<script>
// ===== Firebase web config (PUBLIC identifiers; do not put secrets here) =====
const firebaseConfig = {
  apiKey: "AIzaSyA0tQ3pn4M-iPSa7lbKnCAt9cdPORulWPI",
  authDomain: "secret-santa-bd69d.firebaseapp.com",
  projectId: "secret-santa-bd69d",
  storageBucket: "secret-santa-bd69d.firebasestorage.app",
  messagingSenderId: "864686307297",
  appId: "1:864686307297:web:ec2c3f022d704363d844a0",
  measurementId: "G-V6V6R54R0X"
};
// ============================================================================

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

// Auth readiness & helper
let AUTH_READY = false;
let authReadyResolvers = [];
function waitForAuth(){ return AUTH_READY ? Promise.resolve() : new Promise(res=>authReadyResolvers.push(res)); }

auth.onAuthStateChanged((u)=>{
  AUTH_READY = !!u;
  const info = document.querySelector('#authInfo');
  if(info) info.textContent = AUTH_READY ? `Auth: ready (uid ${u.uid.slice(0,6)}â€¦)` : 'Auth: not signed in';
  if (AUTH_READY) { authReadyResolvers.splice(0).forEach(fn=>fn()); initApp(); }
});

auth.signInAnonymously().catch((e)=>{
  console.error('Anon auth error', e);
  alert('Anonymous auth failed. In Firebase Auth â†’ Authorized domains, add your GitHub Pages domain (e.g., yourname.github.io).');
});

// UI helpers
const $ = (s)=>document.querySelector(s);
const viewAdmin = $('#view-admin');
const viewSession  = $('#view-session');
const ov = $('#ov');
const targetEl = $('#target');

function parseQuery(){
  const u = new URL(location.href);
  return { sid: u.searchParams.get('session') || u.searchParams.get('s') };
}
function show(id){ [viewAdmin, viewSession].forEach(el=>el.classList.add('hide')); id.classList.remove('hide'); }

// Utils
function randToken(n=12){ return btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(n)))).replace(/[^A-Za-z0-9]/g,'').slice(0, n+5); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const r=new Uint32Array(1); crypto.getRandomValues(r); const j=r[0]%(i+1); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function genDerangement(n, forbid=true, maxT=200000){
  if(n<3) throw new Error('Need at least 3');
  for(let t=0;t<maxT;t++){
    const p=[...Array(n).keys()]; shuffle(p);
    if(p.some((v,i)=>v===i)) continue;
    if(forbid && p.some((v,i)=>p[v]===i)) continue;
    return p;
  }
  throw new Error('Could not generate mapping');
}

async function initApp(){
  await waitForAuth();
  const {sid} = parseQuery();
  if(!sid){ show(viewAdmin); setupAdmin(); }
  else { show(viewSession); setupSharedSession(sid); }
}

// Admin view (create session & share one link)
function setupAdmin(){
  $('#btnCreate').addEventListener('click', async ()=>{
    await waitForAuth();
    const names = $('#names').value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    if(names.length < 3) return alert('At least 3 names.');
    const noTwo = $('#noTwo').checked;
    const perm = genDerangement(names.length, noTwo);

    const sid = randToken(16);
    const sessRef = db.collection('sessions').doc(sid);
    const ownerUid = auth.currentUser?.uid || 'anonymous';

    // 1) Create session doc first
    await sessRef.set({ createdAt: new Date().toISOString(), ownerUid, count:names.length, noTwo });

    // 2) Create players (public) and secrets (target)
    const batch = db.batch();
    const players = [];
    for(let i=0;i<names.length;i++){
      const name = names[i];
      const pid = randToken(12);
      const target = names[perm[i]];
      players.push({pid,name});
      batch.set(sessRef.collection('players').doc(pid), { name, revealed:false, createdAt: new Date().toISOString() });
      batch.set(sessRef.collection('secrets').doc(pid), { target });
    }

    // Commit players + secrets first (works with your current rules)
    await batch.commit();

    // 2b) OPTIONAL: write public index in a separate call.
    // If your rules don't include /meta create permissions, this will gracefully fall back.
    try {
      await sessRef.collection('meta').doc('players_index').set({ entries: players, createdAt: new Date().toISOString() });
    } catch (e) {
      console.warn('players_index write skipped (rules deny create on /meta). Falling back to collection listener.', e);
    }

    // 3) Show shareable link
    const base = location.origin + location.pathname;
    const sessionUrl = `${base}?session=${encodeURIComponent(sid)}`;
    const shareDiv = $('#share');
    shareDiv.innerHTML = `
      <div class="row">
        <input id="shareLink" value="${sessionUrl}" readonly />
        <button class="secondary copy" id="copyBtn">Copy</button>
      </div>
      <div class="muted" style="margin-top:8px">Share this URL. Everyone will see the buttons for all names and can reveal their own.</div>
    `;
    $('#copyBtn').onclick = ()=>{ navigator.clipboard.writeText(sessionUrl).then(()=>alert('Link copied')); };

    // 4) Live status for creator as well
    attachSharedStatus(sessRef, sid);
  });
}

// Shared Session page â€” anyone with the link
function setupSharedSession(sid){
  const sessRef = db.collection('sessions').doc(sid);
  const info = $('#sessInfo');
  info.textContent = `Session: ${sid}`;
  attachSharedStatus(sessRef, sid);
}

function attachSharedStatus(sessRef, sid){
  const grid = $('#nameGrid');
  const statusDiv = $('#sessionStatus');

  // Keep a map of player states
  const players = new Map(); // pid -> {name,revealed}

  // Render function
  function render(){
    grid.innerHTML = '';
    let done = 0; const total = players.size;
    [...players.entries()].sort((a,b)=>a[1].name.localeCompare(b[1].name)).forEach(([pid, pl])=>{
      if(pl.revealed) done++;
      const btn = document.createElement('button');
      btn.className = 'nameBtn';
      btn.disabled = !!pl.revealed;
      btn.innerHTML = pl.revealed ? `${pl.name} âœ…` : `${pl.name} â€” Reveal`;
      btn.addEventListener('click', ()=>confirmAndReveal(sessRef, sid, pid, pl.name));
      grid.appendChild(btn);
    });
    statusDiv.innerHTML = `<div class='pill'>Revealed: <b>${done}</b> / ${total}</div>`;
  }

  // Strategy: first try public index (no list perms needed). If missing, fall back to collection listen.
  sessRef.collection('meta').doc('players_index').get().then(idx=>{
    if(idx.exists){
      const {entries=[]} = idx.data();
      entries.forEach(e=>players.set(e.pid, {name:e.name, revealed:false}));
      render();
      // per-doc listeners
      for(const e of entries){
        sessRef.collection('players').doc(e.pid).onSnapshot(doc=>{
          if(doc.exists){ const d = doc.data(); players.set(doc.id, {name:e.name, revealed:!!d.revealed}); render(); }
        }, err=>{ console.error('Player doc listen error', err); });
      }
    } else {
      // Fallback: direct collection subscription (requires allow list on players)
      sessRef.collection('players').onSnapshot(snap=>{
        players.clear();
        snap.forEach(doc=>{ const d=doc.data(); players.set(doc.id, {name:d.name, revealed:!!d.revealed}); });
        render();
      }, err=>{
        console.error('Players subscribe error', err);
        grid.innerHTML = `<span class='err'>Cannot list players. Either publish the rules with <code>allow read</code> on <code>players</code>, or rely on the built-in public index (create a new session).</span>`;
      });
    }
  }).catch(err=>{
    console.error('Index read error', err);
    grid.innerHTML = `<span class='err'>Cannot load session index. Check Firestore rules.</span>`;
  });
}

async function confirmAndReveal(sessRef, sid, pid, name){
  if(!confirm(`Are you ${name}?`)) return;
  try{
    await waitForAuth();
    const playerRef = sessRef.collection('players').doc(pid);
    const secretRef = sessRef.collection('secrets').doc(pid);

    const snap = await playerRef.get();
    if(!snap.exists) return alert('Player not found.');
    if(snap.data().revealed) return alert('Already revealed.');

    // Flip revealed first (rules require this before reading secret)
    await playerRef.update({ revealed:true, revealedAt: new Date().toISOString() });

    // Read target and show privately in this client
    const sec = await secretRef.get();
    const tgt = sec.exists ? sec.data().target : '(missing)';
    targetEl.textContent = tgt; ov.style.display='flex';
  }catch(e){
    console.error('Reveal error', e);
    alert('Reveal failed due to permissions. Ensure Anonymous Auth is enabled, rules are published, and your domain is authorized.');
  }
}

$('#closeOv').addEventListener('click', ()=>{ ov.style.display='none'; });

/* =======================
   Minimal self-tests (console)
   ======================= */
(function selfTests(){
  try {
    // split tests (\n and \r\n), blank-line trimming
    const raw = "Alice\nBob\r\nCharlie\n\n";
    const arr = raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    console.assert(arr.length===3 && arr[0]==='Alice' && arr[1]==='Bob' && arr[2]==='Charlie', 'Split test failed');

    // derangement tests: forbid 2-cycles
    for(let n=3;n<=10;n++){
      const p = genDerangement(n, true);
      console.assert(p.every((v,i)=>v!==i), 'Derangement fixed point fail');
      let two=false; for(let i=0;i<n;i++){ if(p[p[i]]===i){ two=true; break; } }
      console.assert(!two, 'Derangement 2-cycle fail');
    }

    // derangement tests: allow 2-cycles but still no fixed points
    for(let n=3;n<=10;n++){
      const p = genDerangement(n, false);
      console.assert(p.every((v,i)=>v!==i), 'Derangement (noTwo=false) fixed point fail');
    }

    // token format
    const tok = randToken(16); console.assert(/^[A-Za-z0-9]{10,}$/.test(tok), 'Token format');

    // index render smoke test
    const entries = [{pid:'p1',name:'Amy'},{pid:'p2',name:'Ben'}];
    const map = new Map(entries.map(e=>[e.pid,{name:e.name, revealed:false}]));
    map.get('p1').revealed = true;
    const done = [...map.values()].filter(v=>v.revealed).length; console.assert(done===1, 'Status count');

    console.log('%cSelf-tests passed','color:#22c55e');
  } catch(e){ console.warn('Self-tests error:', e); }
})();
</script>
</body>
</html>
